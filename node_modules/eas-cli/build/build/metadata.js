"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.truncateGitCommitMessage = exports.collectMetadataAsync = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const resolve_from_1 = tslib_1.__importDefault(require("resolve-from"));
const log_1 = tslib_1.__importDefault(require("../log"));
const projectUtils_1 = require("../project/projectUtils");
const UpdatesModule_1 = require("../update/android/UpdatesModule");
const UpdatesModule_2 = require("../update/ios/UpdatesModule");
const actions_1 = require("../user/actions");
const easCli_1 = require("../utils/easCli");
const vcs_1 = require("../vcs");
const version_1 = require("./android/version");
const version_2 = require("./ios/version");
async function collectMetadataAsync(ctx) {
    var _a, _b, _c;
    const vcsClient = (0, vcs_1.getVcsClient)();
    const channelOrReleaseChannel = await resolveChannelOrReleaseChannelAsync(ctx);
    const distribution = (_a = ('simulator' in ctx.buildProfile && ctx.buildProfile.simulator
        ? 'simulator'
        : ctx.buildProfile.distribution)) !== null && _a !== void 0 ? _a : 'store';
    const metadata = {
        trackingContext: ctx.trackingCtx,
        ...(await maybeResolveVersionsAsync(ctx)),
        cliVersion: easCli_1.easCliVersion,
        workflow: ctx.workflow,
        credentialsSource: ctx.buildProfile.credentialsSource,
        sdkVersion: ctx.exp.sdkVersion,
        runtimeVersion: (_b = config_plugins_1.Updates.getRuntimeVersionNullable(ctx.exp, ctx.platform)) !== null && _b !== void 0 ? _b : undefined,
        reactNativeVersion: await getReactNativeVersionAsync(ctx),
        ...channelOrReleaseChannel,
        distribution,
        appName: ctx.exp.name,
        appIdentifier: resolveAppIdentifier(ctx),
        buildProfile: ctx.buildProfileName,
        gitCommitHash: await vcsClient.getCommitHashAsync(),
        gitCommitMessage: truncateGitCommitMessage((_c = (await vcsClient.getLastCommitMessageAsync())) !== null && _c !== void 0 ? _c : undefined),
        isGitWorkingTreeDirty: await vcsClient.hasUncommittedChangesAsync(),
        username: (0, projectUtils_1.getUsername)(ctx.exp, await (0, actions_1.ensureLoggedInAsync)()),
        message: ctx.message,
        ...(ctx.platform === eas_build_job_1.Platform.IOS && {
            iosEnterpriseProvisioning: resolveIosEnterpriseProvisioning(ctx),
        }),
        runWithNoWaitFlag: ctx.noWait,
        runFromCI: ctx.runFromCI,
    };
    return (0, eas_build_job_1.sanitizeMetadata)(metadata);
}
exports.collectMetadataAsync = collectMetadataAsync;
async function maybeResolveVersionsAsync(ctx) {
    if (ctx.platform === eas_build_job_1.Platform.IOS) {
        const iosContext = ctx;
        const resolvedVersion = await (0, version_2.maybeResolveVersionsAsync)(ctx.projectDir, ctx.exp, iosContext.ios.targets);
        if (iosContext.ios.buildNumberOverride) {
            return {
                ...resolvedVersion,
                appBuildVersion: iosContext.ios.buildNumberOverride,
            };
        }
        return resolvedVersion;
    }
    else if (ctx.platform === eas_build_job_1.Platform.ANDROID) {
        const androidCtx = ctx;
        const resolvedVersion = await (0, version_1.maybeResolveVersionsAsync)(ctx.projectDir, ctx.exp, androidCtx.buildProfile);
        if (androidCtx.android.versionCodeOverride) {
            return {
                ...resolvedVersion,
                appBuildVersion: androidCtx.android.versionCodeOverride,
            };
        }
        return resolvedVersion;
    }
    else {
        throw new Error(`Unsupported platform ${ctx.platform}`);
    }
}
function resolveAppIdentifier(ctx) {
    if (ctx.platform === eas_build_job_1.Platform.IOS) {
        return ctx.ios.bundleIdentifier;
    }
    else {
        return ctx.android.applicationId;
    }
}
async function resolveChannelOrReleaseChannelAsync(ctx) {
    if (!(0, projectUtils_1.isExpoUpdatesInstalled)(ctx.projectDir)) {
        return null;
    }
    if (ctx.buildProfile.channel) {
        return { channel: ctx.buildProfile.channel };
    }
    if (ctx.buildProfile.releaseChannel) {
        return { releaseChannel: ctx.buildProfile.releaseChannel };
    }
    const channel = await getNativeChannelAsync(ctx);
    if (channel) {
        return { channel };
    }
    const releaseChannel = await getNativeReleaseChannelAsync(ctx);
    return { releaseChannel };
}
async function getNativeReleaseChannelAsync(ctx) {
    var _a, _b;
    switch (ctx.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            return (_a = (await (0, UpdatesModule_1.readReleaseChannelSafelyAsync)(ctx.projectDir))) !== null && _a !== void 0 ? _a : 'default';
        }
        case eas_build_job_1.Platform.IOS: {
            return (_b = (await (0, UpdatesModule_2.readReleaseChannelSafelyAsync)(ctx.projectDir))) !== null && _b !== void 0 ? _b : 'default';
        }
        default:
            return 'default';
    }
}
async function getNativeChannelAsync(ctx) {
    var _a, _b;
    switch (ctx.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            return (_a = (await (0, UpdatesModule_1.readChannelSafelyAsync)(ctx.projectDir))) !== null && _a !== void 0 ? _a : undefined;
        }
        case eas_build_job_1.Platform.IOS: {
            return (_b = (await (0, UpdatesModule_2.readChannelSafelyAsync)(ctx.projectDir))) !== null && _b !== void 0 ? _b : undefined;
        }
    }
    return undefined;
}
async function getReactNativeVersionAsync(ctx) {
    try {
        const reactNativePackageJsonPath = (0, resolve_from_1.default)(ctx.projectDir, 'react-native/package.json');
        return (await fs_extra_1.default.readJson(reactNativePackageJsonPath)).version;
    }
    catch (err) {
        log_1.default.debug('Failed to resolve react-native version:');
        log_1.default.debug(err);
        return undefined;
    }
}
function resolveIosEnterpriseProvisioning(ctx) {
    return ctx.buildProfile.enterpriseProvisioning;
}
function truncateGitCommitMessage(msg, maxLength = 4096) {
    if (msg === undefined) {
        return undefined;
    }
    return msg.length > maxLength ? `${msg.substring(0, maxLength - 3)}...` : msg;
}
exports.truncateGitCommitMessage = truncateGitCommitMessage;
