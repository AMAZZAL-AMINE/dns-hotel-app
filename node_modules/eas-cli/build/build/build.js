"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForBuildEndAsync = exports.prepareBuildRequestForPlatformAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_progress_1 = tslib_1.__importDefault(require("cli-progress"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const common_1 = require("../analytics/common");
const events_1 = require("../analytics/events");
const api_1 = require("../api");
const generated_1 = require("../graphql/generated");
const BuildQuery_1 = require("../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importStar(require("../log"));
const ora_1 = require("../ora");
const platform_1 = require("../platform");
const uploads_1 = require("../uploads");
const files_1 = require("../utils/files");
const progress_1 = require("../utils/progress");
const promise_1 = require("../utils/promise");
const vcs_1 = require("../vcs");
const local_1 = require("./local");
const metadata_1 = require("./metadata");
const printBuildInfo_1 = require("./utils/printBuildInfo");
const repository_1 = require("./utils/repository");
function resolveBuildParamsInput(ctx) {
    return {
        resourceClass: ctx.resourceClass,
    };
}
async function prepareBuildRequestForPlatformAsync(builder) {
    const { ctx } = builder;
    const credentialsResult = await (0, common_1.withAnalyticsAsync)(async () => await builder.ensureCredentialsAsync(ctx), {
        attemptEvent: events_1.BuildEvent.GATHER_CREDENTIALS_ATTEMPT,
        successEvent: events_1.BuildEvent.GATHER_CREDENTIALS_SUCCESS,
        failureEvent: events_1.BuildEvent.GATHER_CREDENTIALS_FAIL,
        trackingCtx: ctx.trackingCtx,
    });
    await (0, common_1.withAnalyticsAsync)(async () => await builder.syncProjectConfigurationAsync(ctx), {
        attemptEvent: events_1.BuildEvent.CONFIGURE_PROJECT_ATTEMPT,
        successEvent: events_1.BuildEvent.CONFIGURE_PROJECT_SUCCESS,
        failureEvent: events_1.BuildEvent.CONFIGURE_PROJECT_FAIL,
        trackingCtx: ctx.trackingCtx,
    });
    if (await (0, vcs_1.getVcsClient)().isCommitRequiredAsync()) {
        log_1.default.addNewLineIfNone();
        await (0, repository_1.reviewAndCommitChangesAsync)(`[EAS Build] Run EAS Build for ${platform_1.requestedPlatformDisplayNames[ctx.platform]}`, { nonInteractive: ctx.nonInteractive });
    }
    const projectArchive = ctx.localBuildOptions.enable
        ? {
            type: eas_build_job_1.ArchiveSourceType.PATH,
            path: (await (0, repository_1.makeProjectTarballAsync)()).path,
        }
        : {
            type: eas_build_job_1.ArchiveSourceType.S3,
            bucketKey: await uploadProjectAsync(ctx),
        };
    const metadata = await (0, metadata_1.collectMetadataAsync)(ctx);
    const buildParams = resolveBuildParamsInput(ctx);
    const job = await builder.prepareJobAsync(ctx, {
        projectArchive,
        credentials: credentialsResult === null || credentialsResult === void 0 ? void 0 : credentialsResult.credentials,
    });
    return async () => {
        if (ctx.localBuildOptions.enable) {
            await (0, local_1.runLocalBuildAsync)(job, metadata, ctx.localBuildOptions);
            return undefined;
        }
        else {
            try {
                return await sendBuildRequestAsync(builder, job, metadata, buildParams);
            }
            catch (error) {
                handleBuildRequestError(error, job.platform);
            }
        }
    };
}
exports.prepareBuildRequestForPlatformAsync = prepareBuildRequestForPlatformAsync;
function handleBuildRequestError(error, platform) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (((_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.errorCode) === 'TURTLE_DEPRECATED_JOB_FORMAT') {
        log_1.default.error('EAS Build API has changed. Upgrade to the latest eas-cli version.');
        throw new Error('Build request failed.');
    }
    else if (((_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.extensions) === null || _f === void 0 ? void 0 : _f.errorCode) === 'EAS_BUILD_DOWN_FOR_MAINTENANCE') {
        log_1.default.error('EAS Build is down for maintenance. Try again later. Check https://status.expo.dev/ for updates.');
        throw new Error('Build request failed.');
    }
    else if (((_j = (_h = (_g = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _g === void 0 ? void 0 : _g[0]) === null || _h === void 0 ? void 0 : _h.extensions) === null || _j === void 0 ? void 0 : _j.errorCode) === 'EAS_BUILD_FREE_TIER_DISABLED') {
        log_1.default.error('EAS Build free tier is temporarily disabled. Try again later. Check https://status.expo.dev/ for updates.');
        throw new Error('Build request failed.');
    }
    else if (((_m = (_l = (_k = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _k === void 0 ? void 0 : _k[0]) === null || _l === void 0 ? void 0 : _l.extensions) === null || _m === void 0 ? void 0 : _m.errorCode) === 'EAS_BUILD_TOO_MANY_PENDING_BUILDS') {
        log_1.default.error(`You have already reached the maximum number of pending ${platform_1.requestedPlatformDisplayNames[platform]} builds for your account. Try again later.`);
        throw new Error('Build request failed.');
    }
    else if (error === null || error === void 0 ? void 0 : error.graphQLErrors) {
        log_1.default.error('Build request failed. Make sure you are using the latest eas-cli version. If the problem persists, report the issue.');
    }
    throw error;
}
async function uploadProjectAsync(ctx) {
    let projectTarballPath;
    try {
        return await (0, common_1.withAnalyticsAsync)(async () => {
            log_1.default.newLine();
            log_1.default.log(`Compressing project files and uploading to EAS Build. ${(0, log_1.learnMore)('https://expo.fyi/eas-build-archive')}`);
            const projectTarball = await (0, repository_1.makeProjectTarballAsync)();
            projectTarballPath = projectTarball.path;
            const { bucketKey } = await (0, uploads_1.uploadFileAtPathToS3Async)(generated_1.UploadSessionType.EasBuildProjectSources, projectTarball.path, (0, progress_1.createProgressTracker)({
                total: projectTarball.size,
                message: ratio => `Uploading to EAS Build (${(0, files_1.formatBytes)(projectTarball.size * ratio)} / ${(0, files_1.formatBytes)(projectTarball.size)})`,
                completedMessage: (duration) => `Uploaded to EAS ${chalk_1.default.dim(duration)}`,
            }));
            return bucketKey;
        }, {
            attemptEvent: events_1.BuildEvent.PROJECT_UPLOAD_ATTEMPT,
            successEvent: events_1.BuildEvent.PROJECT_UPLOAD_SUCCESS,
            failureEvent: events_1.BuildEvent.PROJECT_UPLOAD_FAIL,
            trackingCtx: ctx.trackingCtx,
        });
    }
    finally {
        if (projectTarballPath) {
            await fs_extra_1.default.remove(projectTarballPath);
        }
    }
}
async function sendBuildRequestAsync(builder, job, metadata, buildParams) {
    const { ctx } = builder;
    return await (0, common_1.withAnalyticsAsync)(async () => {
        if (log_1.default.isDebug) {
            log_1.default.log(`Starting ${platform_1.requestedPlatformDisplayNames[job.platform]} build`);
        }
        const { build, deprecationInfo } = await builder.sendBuildRequestAsync(ctx.projectId, job, metadata, buildParams);
        (0, printBuildInfo_1.printDeprecationWarnings)(deprecationInfo);
        return build;
    }, {
        attemptEvent: events_1.BuildEvent.BUILD_REQUEST_ATTEMPT,
        successEvent: events_1.BuildEvent.BUILD_REQUEST_SUCCESS,
        failureEvent: events_1.BuildEvent.BUILD_REQUEST_FAIL,
        trackingCtx: ctx.trackingCtx,
    });
}
async function waitForBuildEndAsync({ buildIds, accountName }, { intervalSec = 10 } = {}) {
    let spinner;
    let originalSpinnerText;
    if (buildIds.length === 1) {
        log_1.default.log('Waiting for build to complete. You can press Ctrl+C to exit.');
        originalSpinnerText = 'Waiting for build to complete.';
        spinner = (0, ora_1.ora)(originalSpinnerText).start();
    }
    else {
        originalSpinnerText = 'Waiting for builds to complete. You can press Ctrl+C to exit.';
        spinner = (0, ora_1.ora)('Waiting for builds to complete. You can press Ctrl+C to exit.').start();
    }
    while (true) {
        const builds = await getBuildsSafelyAsync(buildIds);
        const { refetch } = builds.length === 1
            ? await handleSingleBuildProgressAsync({ build: builds[0], accountName }, { spinner })
            : await handleMultipleBuildsProgressAsync({ builds }, { spinner, originalSpinnerText });
        if (!refetch) {
            return builds;
        }
        await (0, promise_1.sleepAsync)(intervalSec * 1000);
    }
}
exports.waitForBuildEndAsync = waitForBuildEndAsync;
async function getBuildsSafelyAsync(buildIds) {
    const promises = buildIds.map(async (buildId) => {
        try {
            return await BuildQuery_1.BuildQuery.byIdAsync(buildId, { useCache: false });
        }
        catch (err) {
            log_1.default.debug('Failed to fetch the build status', err);
            return null;
        }
    });
    return await Promise.all(promises);
}
let queueProgressBarStarted = false;
const queueProgressBar = new cli_progress_1.default.SingleBar({ format: '|{bar}| {estimatedWaitTime}' }, cli_progress_1.default.Presets.rect);
async function handleSingleBuildProgressAsync({ build, accountName }, { spinner }) {
    if (build === null) {
        spinner.text = 'Could not fetch the build status. Check your network connection.';
        return { refetch: true };
    }
    if (queueProgressBarStarted && (build === null || build === void 0 ? void 0 : build.status) && build.status !== generated_1.BuildStatus.InQueue) {
        if (build.status === generated_1.BuildStatus.InProgress) {
            queueProgressBar.update(queueProgressBar.getTotal(), {
                estimatedWaitTime: '',
            });
        }
        queueProgressBar.stop();
        log_1.default.newLine();
        queueProgressBarStarted = false;
        spinner.start('Build is about to start');
    }
    switch (build.status) {
        case generated_1.BuildStatus.Finished:
            spinner.succeed('Build finished');
            return { refetch: false };
        case generated_1.BuildStatus.New:
            spinner.text = `Build is waiting to enter the queue. Check your concurrency limit at ${chalk_1.default.underline(formatAccountSubscriptionsUrl(accountName))}.`;
            break;
        case generated_1.BuildStatus.InQueue: {
            spinner.text = 'Build queued...';
            const progressBarPayload = typeof build.estimatedWaitTimeLeftSeconds === 'number'
                ? { estimatedWaitTime: formatEstimatedWaitTime(build.estimatedWaitTimeLeftSeconds) }
                : { estimatedWaitTime: '' };
            if (!queueProgressBarStarted &&
                typeof build.initialQueuePosition === 'number' &&
                typeof build.queuePosition === 'number') {
                spinner.stopAndPersist();
                if (build.priority !== generated_1.BuildPriority.High) {
                    log_1.default.newLine();
                    log_1.default.log('Start builds sooner in the priority queue.');
                    log_1.default.log(`Sign up for EAS Production or Enterprise at ${chalk_1.default.underline(formatAccountSubscriptionsUrl(accountName))}`);
                }
                log_1.default.newLine();
                log_1.default.log(`Waiting in ${priorityToQueueDisplayName[build.priority]}`);
                queueProgressBar.start(build.initialQueuePosition + 1, build.initialQueuePosition - build.queuePosition + 1, progressBarPayload);
                queueProgressBarStarted = true;
            }
            if (typeof build.queuePosition === 'number') {
                queueProgressBar.update(build.queuePosition, progressBarPayload);
            }
            break;
        }
        case generated_1.BuildStatus.Canceled:
            spinner.fail('Build canceled');
            return { refetch: false };
        case generated_1.BuildStatus.InProgress:
            spinner.text = 'Build in progress...';
            break;
        case generated_1.BuildStatus.Errored:
            spinner.fail('Build failed');
            if (build.error) {
                return { refetch: false };
            }
            else {
                throw new Error('Standalone build failed!');
            }
        default:
            spinner.warn('Unknown status');
            throw new Error(`Unknown build status: ${build.status} - aborting!`);
    }
    return { refetch: true };
}
const priorityToQueueDisplayName = {
    [generated_1.BuildPriority.Normal]: 'queue',
    [generated_1.BuildPriority.NormalPlus]: 'queue',
    [generated_1.BuildPriority.High]: 'priority queue',
};
const statusToDisplayName = {
    [generated_1.BuildStatus.New]: 'waiting to enter the queue (concurrency limit reached)',
    [generated_1.BuildStatus.InQueue]: 'in queue',
    [generated_1.BuildStatus.InProgress]: 'in progress',
    [generated_1.BuildStatus.Canceled]: 'canceled',
    [generated_1.BuildStatus.Finished]: 'finished',
    [generated_1.BuildStatus.Errored]: 'failed',
};
const platforms = [generated_1.AppPlatform.Android, generated_1.AppPlatform.Ios];
async function handleMultipleBuildsProgressAsync({ builds: maybeBuilds }, { spinner, originalSpinnerText }) {
    const buildCount = maybeBuilds.length;
    const builds = maybeBuilds.filter(isBuildFragment);
    const allFinished = builds.filter(build => build.status === generated_1.BuildStatus.Finished).length === buildCount;
    const allSettled = builds.filter(build => [generated_1.BuildStatus.Finished, generated_1.BuildStatus.Errored, generated_1.BuildStatus.Canceled].includes(build.status)).length === buildCount;
    if (allSettled) {
        if (allFinished) {
            spinner.succeed(formatSettledBuildsText(builds));
        }
        else {
            spinner.fail(formatSettledBuildsText(builds));
        }
        return { refetch: false };
    }
    else {
        spinner.text = formatPendingBuildsText(originalSpinnerText, builds);
        return { refetch: true };
    }
}
function formatSettledBuildsText(builds) {
    return platforms
        .map(platform => {
        const build = (0, nullthrows_1.default)(builds.find(build => build.platform === platform), `Build for platform ${platform} must be defined in this context`);
        return `${platform_1.appPlatformEmojis[platform]} ${platform_1.appPlatformDisplayNames[platform]} build - status: ${chalk_1.default.bold(statusToDisplayName[build.status])}`;
    })
        .join('\n  ');
}
function formatPendingBuildsText(originalSpinnerText, builds) {
    return [
        originalSpinnerText,
        ...platforms.map(platform => {
            const build = builds.find(build => build.platform === platform);
            const status = build ? statusToDisplayName[build.status] : 'unknown';
            let extraInfo = '';
            if ((build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.InQueue &&
                typeof build.initialQueuePosition === 'number' &&
                typeof build.queuePosition === 'number') {
                const percent = Math.floor(((build.initialQueuePosition - build.queuePosition + 1) /
                    (build.initialQueuePosition + 1)) *
                    100);
                const estimatedWaitTime = typeof build.estimatedWaitTimeLeftSeconds === 'number'
                    ? ` - ${formatEstimatedWaitTime(build.estimatedWaitTimeLeftSeconds)}`
                    : '';
                extraInfo = ` - queue progress: ${chalk_1.default.bold(`${percent}%`)}${estimatedWaitTime}`;
            }
            return `${platform_1.appPlatformEmojis[platform]} ${platform_1.appPlatformDisplayNames[platform]} build - status: ${chalk_1.default.bold(status)}${extraInfo}`;
        }),
    ].join('\n  ');
}
function isBuildFragment(maybeBuild) {
    return maybeBuild !== null;
}
function formatEstimatedWaitTime(estimatedWaitTimeLeftSeconds) {
    if (estimatedWaitTimeLeftSeconds < 5 * 60) {
        return 'starting soon...';
    }
    else {
        const n = Math.floor(estimatedWaitTimeLeftSeconds / (10 * 60)) + 1;
        return `starting in about ${n}0 minutes...`;
    }
}
function formatAccountSubscriptionsUrl(accountName) {
    return new URL(`/accounts/${accountName}/settings/subscriptions`, (0, api_1.getExpoWebsiteBaseUrl)()).toString();
}
