"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listAndRenderUpdatesOnBranchByNameAsync = exports.UPDATES_LIMIT = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_table3_1 = tslib_1.__importDefault(require("cli-table3"));
const UpdateQuery_1 = require("../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importDefault(require("../log"));
const formatFields_1 = tslib_1.__importDefault(require("../utils/formatFields"));
const json_1 = require("../utils/json");
const queries_1 = require("../utils/queries");
const utils_1 = require("./utils");
exports.UPDATES_LIMIT = 50;
async function listAndRenderUpdatesOnBranchByNameAsync(projectId, branchName, options) {
    var _a, _b;
    if (options.nonInteractive) {
        const updates = await queryUpdateGroupsForBranchAsync((_a = options.limit) !== null && _a !== void 0 ? _a : exports.UPDATES_LIMIT, options.offset, projectId, branchName);
        renderUpdateGroups(updates, options, branchName);
    }
    else {
        await (0, queries_1.paginatedQueryWithConfirmPromptAsync)({
            limit: (_b = options.limit) !== null && _b !== void 0 ? _b : exports.UPDATES_LIMIT,
            offset: options.offset,
            queryToPerform: (limit, offset) => queryUpdateGroupsForBranchAsync(limit, offset, projectId, branchName),
            promptOptions: {
                title: 'Load more branches?',
                renderListItems: updates => renderUpdateGroups(updates, options, branchName),
            },
        });
    }
}
exports.listAndRenderUpdatesOnBranchByNameAsync = listAndRenderUpdatesOnBranchByNameAsync;
async function queryUpdateGroupsForBranchAsync(limit, offset, projectId, branchName) {
    const { app } = await UpdateQuery_1.UpdateQuery.viewBranchAsync({
        appId: projectId,
        name: branchName,
        limit,
        offset,
    });
    const updateBranch = app === null || app === void 0 ? void 0 : app.byId.updateBranchByName;
    if (!updateBranch) {
        throw new Error(`Could not find branch "${branchName}"`);
    }
    return updateBranch.updates;
}
function renderUpdateGroups(updates, { json }, branchName) {
    var _a, _b;
    const branch = { name: branchName, id: (_b = (_a = updates[0]) === null || _a === void 0 ? void 0 : _a.branch.id) !== null && _b !== void 0 ? _b : 'N/A' };
    if (json) {
        (0, json_1.printJsonOnlyOutput)({ ...branch, currentPage: updates });
    }
    else {
        const updateGroupsTable = new cli_table3_1.default({
            head: utils_1.UPDATE_COLUMNS,
            wordWrap: true,
        });
        updateGroupsTable.push(...(0, utils_1.getUpdateGroupsWithPlatforms)(updates).map(update => [
            (0, utils_1.formatUpdate)(update),
            update.runtimeVersion,
            update.group,
            update.platforms,
        ]));
        log_1.default.addNewLineIfNone();
        log_1.default.log(chalk_1.default.bold('Branch:'));
        log_1.default.log((0, formatFields_1.default)([
            { label: 'Name', value: branch.name },
            { label: 'ID', value: branch.id },
        ]));
        log_1.default.addNewLineIfNone();
        log_1.default.log(updateGroupsTable.toString());
    }
}
