"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const eas_json_1 = require("@expo/eas-json");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const log_1 = tslib_1.__importDefault(require("../../log"));
const target_1 = require("../../project/ios/target");
const prompts_1 = require("../../prompts");
const credentialsJsonReader = tslib_1.__importStar(require("../credentialsJson/read"));
const utils_1 = require("../credentialsJson/utils");
const BuildCredentialsUtils_1 = require("./actions/BuildCredentialsUtils");
const SetUpBuildCredentials_1 = require("./actions/SetUpBuildCredentials");
const SetUpPushKey_1 = require("./actions/SetUpPushKey");
const provisioningProfile_1 = require("./utils/provisioningProfile");
var PushNotificationSetupOption;
(function (PushNotificationSetupOption) {
    PushNotificationSetupOption[PushNotificationSetupOption["YES"] = 0] = "YES";
    PushNotificationSetupOption[PushNotificationSetupOption["NO"] = 1] = "NO";
    PushNotificationSetupOption[PushNotificationSetupOption["NO_DONT_ASK_AGAIN"] = 2] = "NO_DONT_ASK_AGAIN";
})(PushNotificationSetupOption || (PushNotificationSetupOption = {}));
class IosCredentialsProvider {
    constructor(ctx, options) {
        this.ctx = ctx;
        this.options = options;
        this.platform = eas_build_job_1.Platform.IOS;
    }
    async getCredentialsAsync(src) {
        let buildCredentials;
        if (src === eas_json_1.CredentialsSource.LOCAL) {
            buildCredentials = await this.getLocalAsync();
        }
        else {
            buildCredentials = await this.getRemoteAsync();
        }
        await this.getPushKeyAsync(this.ctx, this.options.targets);
        return buildCredentials;
    }
    async getLocalAsync() {
        const applicationTarget = (0, target_1.findApplicationTarget)(this.options.targets);
        const iosCredentials = await credentialsJsonReader.readIosCredentialsAsync(this.ctx.projectDir, applicationTarget);
        (0, utils_1.ensureAllTargetsAreConfigured)(this.options.targets, iosCredentials);
        for (const target of this.options.targets) {
            this.assertProvisioningProfileType(iosCredentials[target.targetName].provisioningProfile, target.targetName);
        }
        return iosCredentials;
    }
    async getRemoteAsync() {
        return await new SetUpBuildCredentials_1.SetUpBuildCredentials({
            app: this.options.app,
            targets: this.options.targets,
            distribution: this.options.distribution,
            enterpriseProvisioning: this.options.enterpriseProvisioning,
        }).runAsync(this.ctx);
    }
    async getPushKeyAsync(ctx, targets) {
        var _a;
        if (ctx.nonInteractive) {
            return null;
        }
        const applicationTarget = (0, target_1.findApplicationTarget)(targets);
        const app = (0, BuildCredentialsUtils_1.getAppFromContext)(ctx);
        const appLookupParams = {
            ...app,
            bundleIdentifier: applicationTarget.bundleIdentifier,
            parentBundleIdentifier: applicationTarget.parentBundleIdentifier,
        };
        const setupPushKeyAction = new SetUpPushKey_1.SetUpPushKey(appLookupParams);
        const isPushKeySetup = await setupPushKeyAction.isPushKeySetupAsync(ctx);
        if (isPushKeySetup) {
            log_1.default.succeed(`Push Notifications setup for ${app.projectName}: ${applicationTarget.bundleIdentifier}`);
            return null;
        }
        if (((_a = ctx.easJsonCliConfig) === null || _a === void 0 ? void 0 : _a.promptToConfigurePushNotifications) === false) {
            return null;
        }
        const setupOption = await (0, prompts_1.selectAsync)(`Would you like to set up Push Notifications for your project?`, [
            { title: 'Yes', value: PushNotificationSetupOption.YES },
            { title: 'No', value: PushNotificationSetupOption.NO },
            {
                title: `No, don't ask again (preference will be saved to eas.json)`,
                value: PushNotificationSetupOption.NO_DONT_ASK_AGAIN,
            },
        ]);
        if (setupOption === PushNotificationSetupOption.YES) {
            return await setupPushKeyAction.runAsync(ctx);
        }
        else {
            if (setupOption === PushNotificationSetupOption.NO_DONT_ASK_AGAIN) {
                await this.disablePushNotificationsSetupInEasJsonAsync(ctx);
            }
            return null;
        }
    }
    async disablePushNotificationsSetupInEasJsonAsync(ctx) {
        const easJsonPath = eas_json_1.EasJsonReader.formatEasJsonPath(ctx.projectDir);
        const easJson = await fs_extra_1.default.readJSON(easJsonPath);
        easJson.cli = { ...easJson === null || easJson === void 0 ? void 0 : easJson.cli, promptToConfigurePushNotifications: false };
        await fs_extra_1.default.writeFile(easJsonPath, `${JSON.stringify(easJson, null, 2)}\n`);
        log_1.default.withTick('Updated eas.json');
    }
    assertProvisioningProfileType(provisioningProfile, targetName) {
        const isAdHoc = (0, provisioningProfile_1.isAdHocProfile)(provisioningProfile);
        if (this.options.distribution === 'internal' && !isAdHoc) {
            throw new Error(`You must use an adhoc provisioning profile${targetName ? ` (target '${targetName})'` : ''} for internal distribution`);
        }
        else if (this.options.distribution !== 'internal' && isAdHoc) {
            throw new Error(`You can't use an adhoc provisioning profile${targetName ? ` (target '${targetName}')` : ''} for app store distribution`);
        }
    }
}
exports.default = IosCredentialsProvider;
