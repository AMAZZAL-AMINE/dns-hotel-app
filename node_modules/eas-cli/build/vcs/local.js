"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeShallowCopyAsync = exports.Ignore = exports.getRootPath = void 0;
const tslib_1 = require("tslib");
const fast_glob_1 = tslib_1.__importDefault(require("fast-glob"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const path_1 = tslib_1.__importDefault(require("path"));
const EASIGNORE_FILENAME = '.easignore';
const GITIGNORE_FILENAME = '.gitignore';
const DEFAULT_IGNORE = `
.git
node_modules
`;
function getRootPath() {
    var _a;
    const rootPath = (_a = process.env.EAS_PROJECT_ROOT) !== null && _a !== void 0 ? _a : process.cwd();
    if (!path_1.default.isAbsolute(rootPath)) {
        return path_1.default.resolve(process.cwd(), rootPath);
    }
    return rootPath;
}
exports.getRootPath = getRootPath;
/**
 * Ignore wraps the 'ignore' package to support multiple .gitignore files
 * in subdirectories.
 *
 * Inconsistencies with git behavior:
 * - if parent .gitignore has ignore rule and child has exception to that rule,
 *   file will still be ignored,
 * - node_modules is always ignored,
 * - if .easignore exists, .gitignore files are not used.
 */
class Ignore {
    constructor(rootDir) {
        this.rootDir = rootDir;
        this.ignoreMapping = [];
    }
    async initIgnoreAsync() {
        const easIgnorePath = path_1.default.join(this.rootDir, EASIGNORE_FILENAME);
        if (await fs_extra_1.default.pathExists(easIgnorePath)) {
            this.ignoreMapping = [
                ['', (0, ignore_1.default)().add(DEFAULT_IGNORE)],
                ['', (0, ignore_1.default)().add(await this.readIgnoreFileAsync(easIgnorePath))],
            ];
            return;
        }
        const ignoreFilePaths = (await (0, fast_glob_1.default)(`**/${GITIGNORE_FILENAME}`, {
            cwd: this.rootDir,
            ignore: ['node_modules'],
            followSymbolicLinks: false,
        }))
            // ensure that parent dir is before child directories
            .sort((a, b) => a.length - b.length && a.localeCompare(b));
        const ignoreMapping = await Promise.all(ignoreFilePaths.map(async (filePath) => {
            return [
                filePath.slice(0, filePath.length - GITIGNORE_FILENAME.length),
                (0, ignore_1.default)().add(await this.readIgnoreFileAsync(path_1.default.join(this.rootDir, filePath))),
            ];
        }));
        this.ignoreMapping = [['', (0, ignore_1.default)().add(DEFAULT_IGNORE)], ...ignoreMapping];
    }
    ignores(relativePath) {
        for (const [prefix, ignore] of this.ignoreMapping) {
            if (relativePath.startsWith(prefix) && ignore.ignores(relativePath.slice(prefix.length))) {
                return true;
            }
        }
        return false;
    }
    async readIgnoreFileAsync(filePath) {
        const fileContents = await fs_extra_1.default.readFile(filePath, 'utf-8');
        const lines = fileContents.split('\n');
        // Strip trailing '\'. This logic can be removed after fix upstream is released.
        // https://github.com/kaelzhang/node-ignore/issues/81
        return lines
            .map((line) => (line.slice(-1) === '\\' ? line.slice(0, -1) : line))
            .join('\n');
    }
}
exports.Ignore = Ignore;
async function makeShallowCopyAsync(src, dst) {
    const ignore = new Ignore(src);
    await ignore.initIgnoreAsync();
    await fs_extra_1.default.copy(src, dst, {
        filter: (srcFilePath) => {
            if (srcFilePath === src) {
                return true;
            }
            return !ignore.ignores(path_1.default.relative(src, srcFilePath));
        },
    });
}
exports.makeShallowCopyAsync = makeShallowCopyAsync;
