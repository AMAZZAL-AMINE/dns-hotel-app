"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApplePlatformFromSdkRoot = exports.findTargetByName = exports.findApplicationTarget = exports.resolveTargetsAsync = exports.resolveBareProjectTargetsAsync = exports.resolveMangedProjectTargetsAsync = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const joi_1 = tslib_1.__importDefault(require("joi"));
const constants_1 = require("../../credentials/ios/appstore/constants");
const workflow_1 = require("../workflow");
const bundleIdentifier_1 = require("./bundleIdentifier");
const entitlements_1 = require("./entitlements");
const AppExtensionsConfigSchema = joi_1.default.array().items(joi_1.default.object({
    targetName: joi_1.default.string().required(),
    bundleIdentifier: joi_1.default.string().required(),
    parentBundleIdentifier: joi_1.default.string(),
    entitlements: joi_1.default.object(),
}));
async function resolveMangedProjectTargetsAsync({ exp, projectDir, xcodeBuildContext, env, }) {
    var _a, _b, _c, _d, _e, _f;
    const { buildScheme, buildConfiguration } = xcodeBuildContext;
    const applicationTargetName = buildScheme;
    const applicationTargetBundleIdentifier = await (0, bundleIdentifier_1.getBundleIdentifierAsync)(projectDir, exp, {
        targetName: applicationTargetName,
        buildConfiguration,
    });
    const applicationTargetEntitlements = await (0, entitlements_1.getManagedApplicationTargetEntitlementsAsync)(projectDir, env !== null && env !== void 0 ? env : {});
    const appExtensions = (_f = (_e = (_d = (_c = (_b = (_a = exp.extra) === null || _a === void 0 ? void 0 : _a.eas) === null || _b === void 0 ? void 0 : _b.build) === null || _c === void 0 ? void 0 : _c.experimental) === null || _d === void 0 ? void 0 : _d.ios) === null || _e === void 0 ? void 0 : _e.appExtensions) !== null && _f !== void 0 ? _f : [];
    const { error } = AppExtensionsConfigSchema.validate(appExtensions, {
        allowUnknown: false,
        abortEarly: false,
    });
    if (error) {
        throw new Error(`Failed to validate "extra.eas.build.experimental.ios.appExtensions" in you app config.\n${error.message}`);
    }
    const extensionsTargets = appExtensions.map(extension => {
        var _a, _b;
        return ({
            targetName: extension.targetName,
            buildConfiguration,
            bundleIdentifier: extension.bundleIdentifier,
            parentBundleIdentifier: (_a = extension.parentBundleIdentifier) !== null && _a !== void 0 ? _a : applicationTargetBundleIdentifier,
            entitlements: (_b = extension.entitlements) !== null && _b !== void 0 ? _b : {},
        });
    });
    return [
        {
            targetName: applicationTargetName,
            bundleIdentifier: applicationTargetBundleIdentifier,
            buildConfiguration,
            entitlements: applicationTargetEntitlements,
        },
        ...extensionsTargets,
    ];
}
exports.resolveMangedProjectTargetsAsync = resolveMangedProjectTargetsAsync;
async function resolveBareProjectTargetsAsync({ exp, projectDir, xcodeBuildContext, }) {
    const { buildScheme, buildConfiguration } = xcodeBuildContext;
    const result = [];
    const pbxProject = config_plugins_1.IOSConfig.XcodeUtils.getPbxproj(projectDir);
    const applicationTarget = await config_plugins_1.IOSConfig.Target.findApplicationTargetWithDependenciesAsync(projectDir, buildScheme);
    const bundleIdentifier = await (0, bundleIdentifier_1.getBundleIdentifierAsync)(projectDir, exp, {
        targetName: applicationTarget.name,
        buildConfiguration,
    });
    const entitlements = await (0, entitlements_1.getNativeTargetEntitlementsAsync)(projectDir, {
        targetName: applicationTarget.name,
        buildConfiguration,
    });
    result.push({
        targetName: applicationTarget.name,
        bundleIdentifier,
        buildConfiguration,
        entitlements: entitlements !== null && entitlements !== void 0 ? entitlements : {},
        buildSettings: resolveBareProjectBuildSettings(pbxProject, applicationTarget.name, buildConfiguration),
    });
    const dependencies = await resolveBareProjectDependenciesAsync({
        exp,
        projectDir,
        buildConfiguration,
        target: applicationTarget,
        bundleIdentifier,
        pbxProject,
    });
    if (dependencies.length > 0) {
        result.push(...dependencies);
    }
    return result;
}
exports.resolveBareProjectTargetsAsync = resolveBareProjectTargetsAsync;
async function resolveTargetsAsync(opts) {
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(opts.projectDir, eas_build_job_1.Platform.IOS);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        return await resolveBareProjectTargetsAsync(opts);
    }
    else if (workflow === eas_build_job_1.Workflow.MANAGED) {
        return await resolveMangedProjectTargetsAsync(opts);
    }
    else {
        throw new Error(`Unknown workflow: ${workflow}`);
    }
}
exports.resolveTargetsAsync = resolveTargetsAsync;
async function resolveBareProjectDependenciesAsync({ exp, projectDir, buildConfiguration, target, bundleIdentifier, pbxProject, }) {
    const result = [];
    if (target.dependencies && target.dependencies.length > 0) {
        for (const dependency of target.dependencies) {
            const dependencyBundleIdentifier = await (0, bundleIdentifier_1.getBundleIdentifierAsync)(projectDir, exp, {
                targetName: dependency.name,
                buildConfiguration,
            });
            const entitlements = await (0, entitlements_1.getNativeTargetEntitlementsAsync)(projectDir, {
                targetName: target.name,
                buildConfiguration,
            });
            result.push({
                targetName: dependency.name,
                buildConfiguration,
                bundleIdentifier: dependencyBundleIdentifier,
                parentBundleIdentifier: bundleIdentifier,
                entitlements: entitlements !== null && entitlements !== void 0 ? entitlements : {},
                buildSettings: resolveBareProjectBuildSettings(pbxProject, dependency.name, buildConfiguration),
            });
            const dependencyDependencies = await resolveBareProjectDependenciesAsync({
                exp,
                projectDir,
                buildConfiguration,
                target: dependency,
                bundleIdentifier: dependencyBundleIdentifier,
                pbxProject,
            });
            if (dependencyDependencies.length > 0) {
                result.push(...dependencyDependencies);
            }
        }
    }
    return result;
}
function findApplicationTarget(targets) {
    const applicationTarget = targets.find(({ parentBundleIdentifier }) => !parentBundleIdentifier);
    if (!applicationTarget) {
        throw new Error('Could not find the application target');
    }
    return applicationTarget;
}
exports.findApplicationTarget = findApplicationTarget;
function findTargetByName(targets, name) {
    const target = targets.find(target => target.targetName === name);
    if (!target) {
        throw new Error(`Could not find target '${name}'`);
    }
    return target;
}
exports.findTargetByName = findTargetByName;
function resolveBareProjectBuildSettings(project, targetName, buildConfiguration) {
    var _a;
    const xcBuildConfiguration = config_plugins_1.IOSConfig.Target.getXCBuildConfigurationFromPbxproj(project, {
        targetName,
        buildConfiguration,
    });
    return (_a = xcBuildConfiguration === null || xcBuildConfiguration === void 0 ? void 0 : xcBuildConfiguration.buildSettings) !== null && _a !== void 0 ? _a : {};
}
/**
 * Get Apple Platform from the Xcode SDKROOT where possible.
 * @returns - Apple Platform when known, defaults to IOS when unknown
 */
function getApplePlatformFromSdkRoot(target) {
    var _a;
    const sdkRoot = (_a = target.buildSettings) === null || _a === void 0 ? void 0 : _a.SDKROOT;
    if (!sdkRoot) {
        return constants_1.ApplePlatform.IOS;
    }
    if (sdkRoot.includes('iphoneos')) {
        return constants_1.ApplePlatform.IOS;
    }
    else if (sdkRoot.includes('tvos')) {
        return constants_1.ApplePlatform.TV_OS;
    }
    else if (sdkRoot.includes('macosx')) {
        return constants_1.ApplePlatform.MAC_OS;
    }
    else {
        return constants_1.ApplePlatform.IOS;
    }
}
exports.getApplePlatformFromSdkRoot = getApplePlatformFromSdkRoot;
