"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.installExpoUpdatesAsync = exports.validateAppVersionRuntimePolicySupportAsync = exports.isExpoUpdatesInstalledOrAvailable = exports.isExpoUpdatesInstalled = exports.getProjectConfigDescription = exports.getProjectFullNameAsync = exports.getProjectIdAsync = exports.fetchProjectIdFromServerAsync = exports.saveProjectIdToAppConfigAsync = exports.findProjectRootAsync = exports.getProjectAccountNameAsync = exports.getUsername = exports.getProjectAccountName = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const pkg_dir_1 = tslib_1.__importDefault(require("pkg-dir"));
const resolve_from_1 = tslib_1.__importDefault(require("resolve-from"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const generated_1 = require("../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../log"));
const actions_1 = require("../user/actions");
const expoCli_1 = require("../utils/expoCli");
const vcs_1 = require("../vcs");
const ensureProjectExists_1 = require("./ensureProjectExists");
const expoConfig_1 = require("./expoConfig");
function getProjectAccountName(exp, user) {
    switch (user.__typename) {
        case 'User':
            return exp.owner || user.username;
        case 'Robot':
            if (!exp.owner) {
                throw new Error('The "owner" manifest property is required when using robot users. See: https://docs.expo.dev/versions/latest/config/app/#owner');
            }
            return exp.owner;
    }
}
exports.getProjectAccountName = getProjectAccountName;
function getUsername(exp, user) {
    switch (user.__typename) {
        case 'User':
            return user.username;
        case 'Robot':
            // owner field is necessary to run `expo prebuild`
            if (!exp.owner) {
                throw new Error('The "owner" manifest property is required when using robot users. See: https://docs.expo.dev/versions/latest/config/app/#owner');
            }
            // robot users don't have usernames
            return undefined;
    }
}
exports.getUsername = getUsername;
async function getProjectAccountNameAsync(exp) {
    const user = await (0, actions_1.ensureLoggedInAsync)();
    return getProjectAccountName(exp, user);
}
exports.getProjectAccountNameAsync = getProjectAccountNameAsync;
async function findProjectRootAsync({ cwd, defaultToProcessCwd = false, } = {}) {
    const projectRootDir = await (0, pkg_dir_1.default)(cwd);
    if (!projectRootDir) {
        if (!defaultToProcessCwd) {
            throw new Error('Run this command inside a project directory.');
        }
        else {
            return process.cwd();
        }
    }
    else {
        let vcsRoot;
        try {
            vcsRoot = path_1.default.normalize(await (0, vcs_1.getVcsClient)().getRootPathAsync());
        }
        catch { }
        if (vcsRoot && vcsRoot.startsWith(projectRootDir) && vcsRoot !== projectRootDir) {
            throw new Error(`package.json is outside of the current git repository (project root: ${projectRootDir}, git root: ${vcsRoot}.`);
        }
        return projectRootDir;
    }
}
exports.findProjectRootAsync = findProjectRootAsync;
/**
 * Save an EAS project ID to the appropriate field in the app config.
 */
async function saveProjectIdToAppConfigAsync(projectDir, projectId, options = {}) {
    var _a;
    const exp = (0, expoConfig_1.getExpoConfig)(projectDir, options);
    const result = await (0, config_1.modifyConfigAsync)(projectDir, {
        extra: { ...exp.extra, eas: { ...(_a = exp.extra) === null || _a === void 0 ? void 0 : _a.eas, projectId } },
    });
    switch (result.type) {
        case 'success':
            break;
        case 'warn': {
            log_1.default.warn();
            log_1.default.warn(`Warning: Your project uses dynamic app configuration, and the EAS project ID can't automatically be added to it.`);
            log_1.default.warn(chalk_1.default.dim('https://docs.expo.dev/workflow/configuration/#dynamic-configuration-with-appconfigjs'));
            log_1.default.warn();
            log_1.default.warn(`To complete the setup process, set the ${chalk_1.default.bold('extra.eas.projectId')} in your ${chalk_1.default.bold(getProjectConfigDescription(projectDir))}:`);
            log_1.default.warn();
            log_1.default.warn(chalk_1.default.bold(JSON.stringify({ expo: { extra: { eas: { projectId } } } }, null, 2)));
            log_1.default.warn();
            throw new Error(result.message);
        }
        case 'fail':
            throw new Error(result.message);
        default:
            throw new Error('Unexpected result type from modifyConfigAsync');
    }
}
exports.saveProjectIdToAppConfigAsync = saveProjectIdToAppConfigAsync;
/**
 * Use the owner/slug to identify an EAS project on the server.
 *
 * @returns the EAS project ID from the server
 */
async function fetchProjectIdFromServerAsync(exp) {
    const privacy = toAppPrivacy(exp.privacy);
    return await (0, ensureProjectExists_1.ensureProjectExistsAsync)({
        accountName: getProjectAccountName(exp, await (0, actions_1.ensureLoggedInAsync)()),
        projectName: exp.slug,
        privacy,
    });
}
exports.fetchProjectIdFromServerAsync = fetchProjectIdFromServerAsync;
/**
 * Get the EAS project ID from the app config. If the project ID is not set in the config.
 * use the owner/slug to identify an EAS project on the server, and attempt to save the
 * EAS project ID to the appropriate field in the app config.
 */
async function getProjectIdAsync(exp, options = {}, findProjectRootOptions = {}) {
    var _a, _b;
    const localProjectId = (_b = (_a = exp.extra) === null || _a === void 0 ? void 0 : _a.eas) === null || _b === void 0 ? void 0 : _b.projectId;
    if (localProjectId) {
        return localProjectId;
    }
    const projectDir = await findProjectRootAsync(findProjectRootOptions);
    if (!projectDir) {
        throw new Error('Run this command inside a project directory.');
    }
    const projectId = await fetchProjectIdFromServerAsync(exp);
    try {
        await saveProjectIdToAppConfigAsync(projectDir, projectId, options);
    }
    catch (e) {
        // saveProjectIdToAppConfigAsync already printed out a set of detailed errors and
        // instructions on how to fix it. To mimic throwing the error but not halting
        // execution, just warn here with the error message.
        log_1.default.warn(e.message);
    }
    return projectId;
}
exports.getProjectIdAsync = getProjectIdAsync;
const toAppPrivacy = (privacy) => {
    if (privacy === 'public') {
        return generated_1.AppPrivacy.Public;
    }
    else if (privacy === 'hidden') {
        return generated_1.AppPrivacy.Hidden;
    }
    else {
        return generated_1.AppPrivacy.Unlisted;
    }
};
async function getProjectFullNameAsync(exp) {
    const accountName = await getProjectAccountNameAsync(exp);
    return `@${accountName}/${exp.slug}`;
}
exports.getProjectFullNameAsync = getProjectFullNameAsync;
/**
 * Return a useful name describing the project config.
 * - dynamic: app.config.js
 * - static: app.json
 * - custom path app config relative to root folder
 * - both: app.config.js or app.json
 */
function getProjectConfigDescription(projectDir) {
    const paths = (0, config_1.getConfigFilePaths)(projectDir);
    if (paths.dynamicConfigPath) {
        const relativeDynamicConfigPath = path_1.default.relative(projectDir, paths.dynamicConfigPath);
        if (paths.staticConfigPath) {
            return `${relativeDynamicConfigPath} or ${path_1.default.relative(projectDir, paths.staticConfigPath)}`;
        }
        return relativeDynamicConfigPath;
    }
    else if (paths.staticConfigPath) {
        return path_1.default.relative(projectDir, paths.staticConfigPath);
    }
    return 'app.config.js/app.json';
}
exports.getProjectConfigDescription = getProjectConfigDescription;
function isExpoUpdatesInstalled(projectDir) {
    const packageJson = (0, config_1.getPackageJson)(projectDir);
    return !!(packageJson.dependencies && 'expo-updates' in packageJson.dependencies);
}
exports.isExpoUpdatesInstalled = isExpoUpdatesInstalled;
function isExpoUpdatesInstalledOrAvailable(projectDir, sdkVersion) {
    // before sdk 44, expo-updates was included in with the expo module
    if (sdkVersion && semver_1.default.lt(sdkVersion, '44.0.0')) {
        return true;
    }
    return isExpoUpdatesInstalled(projectDir);
}
exports.isExpoUpdatesInstalledOrAvailable = isExpoUpdatesInstalledOrAvailable;
async function validateAppVersionRuntimePolicySupportAsync(projectDir, exp) {
    var _a;
    if (typeof exp.runtimeVersion !== 'object' || ((_a = exp.runtimeVersion) === null || _a === void 0 ? void 0 : _a.policy) !== 'appVersion') {
        return;
    }
    const maybePackageJson = resolve_from_1.default.silent(projectDir, 'expo-updates/package.json');
    if (maybePackageJson) {
        const { version } = await fs_extra_1.default.readJson(maybePackageJson);
        if (semver_1.default.gte(version, '0.14.4')) {
            return;
        }
    }
    log_1.default.warn(`You need to be on SDK 46 or higher, and use expo-updates >= 0.14.4 to use appVersion runtime policy.`);
}
exports.validateAppVersionRuntimePolicySupportAsync = validateAppVersionRuntimePolicySupportAsync;
async function installExpoUpdatesAsync(projectDir) {
    log_1.default.newLine();
    log_1.default.log(`Running ${chalk_1.default.bold('expo install expo-updates')}`);
    log_1.default.newLine();
    await (0, expoCli_1.expoCommandAsync)(projectDir, ['install', 'expo-updates']);
    log_1.default.newLine();
}
exports.installExpoUpdatesAsync = installExpoUpdatesAsync;
