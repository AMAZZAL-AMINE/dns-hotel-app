"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listAndRenderPaginatedBranchesAsync = exports.selectBranchFromPaginatedQueryAsync = exports.BRANCHES_LIMIT = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_table3_1 = tslib_1.__importDefault(require("cli-table3"));
const BranchQuery_1 = require("../graphql/queries/BranchQuery");
const log_1 = tslib_1.__importDefault(require("../log"));
const utils_1 = require("../update/utils");
const json_1 = require("../utils/json");
const queries_1 = require("../utils/queries");
exports.BRANCHES_LIMIT = 50;
async function selectBranchFromPaginatedQueryAsync(projectId, promptTitle, options) {
    var _a;
    if (options.nonInteractive) {
        throw new Error('Unable to select a branch in non-interactive mode.');
    }
    const selectedBranch = await (0, queries_1.paginatedQueryWithSelectPromptAsync)({
        limit: (_a = options.limit) !== null && _a !== void 0 ? _a : exports.BRANCHES_LIMIT,
        offset: options.offset,
        queryToPerform: (limit, offset) => queryBranchesForProjectAsync(limit, offset, projectId),
        promptOptions: {
            title: promptTitle,
            getIdentifierForQueryItem: updateBranchFragment => updateBranchFragment.id,
            createDisplayTextForSelectionPromptListItem: updateBranchFragment => updateBranchFragment.name,
        },
    });
    if (!selectedBranch) {
        throw new Error(`Could not find any branches for project "${projectId}"`);
    }
    return selectedBranch;
}
exports.selectBranchFromPaginatedQueryAsync = selectBranchFromPaginatedQueryAsync;
async function listAndRenderPaginatedBranchesAsync(projectId, options) {
    var _a, _b;
    if (options.nonInteractive) {
        const branches = await queryBranchesForProjectAsync((_a = options.limit) !== null && _a !== void 0 ? _a : exports.BRANCHES_LIMIT, options.offset, projectId);
        renderPageOfBranches(branches, options);
    }
    else {
        await (0, queries_1.paginatedQueryWithConfirmPromptAsync)({
            limit: (_b = options.limit) !== null && _b !== void 0 ? _b : exports.BRANCHES_LIMIT,
            offset: options.offset,
            queryToPerform: (limit, offset) => queryBranchesForProjectAsync(limit, offset, projectId),
            promptOptions: {
                title: 'Load more branches?',
                renderListItems: branches => renderPageOfBranches(branches, options),
            },
        });
    }
}
exports.listAndRenderPaginatedBranchesAsync = listAndRenderPaginatedBranchesAsync;
async function queryBranchesForProjectAsync(limit, offset, projectId) {
    return await BranchQuery_1.BranchQuery.listBranchesAsync({
        appId: projectId,
        limit,
        offset,
    });
}
function renderPageOfBranches(currentPage, { json }) {
    if (json) {
        (0, json_1.printJsonOnlyOutput)(currentPage);
    }
    else {
        const table = new cli_table3_1.default({
            head: ['Branch', ...utils_1.UPDATE_COLUMNS],
            wordWrap: true,
        });
        table.push(...currentPage.map(branch => {
            var _a, _b;
            const update = branch.updates[0];
            return [
                branch.name,
                (0, utils_1.formatUpdate)(update),
                (_a = update === null || update === void 0 ? void 0 : update.runtimeVersion) !== null && _a !== void 0 ? _a : 'N/A',
                (_b = update === null || update === void 0 ? void 0 : update.group) !== null && _b !== void 0 ? _b : 'N/A',
                (update === null || update === void 0 ? void 0 : update.group)
                    ? (0, utils_1.getPlatformsForGroup)({
                        updates: branch.updates,
                        group: update.group,
                    })
                    : 'N/A',
            ];
        }));
        log_1.default.addNewLineIfNone();
        log_1.default.log(chalk_1.default.bold('Branches:'));
        log_1.default.addNewLineIfNone();
        log_1.default.log(table.toString());
    }
}
