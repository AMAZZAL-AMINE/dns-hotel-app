"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadMetadataAsync = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const events_1 = require("../analytics/events");
const log_1 = tslib_1.__importDefault(require("../log"));
const prompts_1 = require("../prompts");
const tasks_1 = require("./apple/tasks");
const config_1 = require("./config");
const context_1 = require("./context");
const errors_1 = require("./errors");
const telemetry_1 = require("./utils/telemetry");
/**
 * Generate a local store configuration from the stores.
 * Note, only App Store is supported at this time.
 */
async function downloadMetadataAsync(metadataCtx) {
    const filePath = (0, config_1.getStaticConfigFilePath)(metadataCtx);
    const fileExists = await fs_extra_1.default.pathExists(filePath);
    if (fileExists) {
        const filePathRelative = path_1.default.relative(metadataCtx.projectDir, filePath);
        const overwrite = await (0, prompts_1.confirmAsync)({
            message: `Do you want to overwrite the existing "${filePathRelative}"?`,
        });
        if (!overwrite) {
            throw new errors_1.MetadataValidationError(`Store config already exists at "${filePath}"`);
        }
    }
    const { app, auth } = await (0, context_1.ensureMetadataAppStoreAuthenticatedAsync)(metadataCtx);
    const { unsubscribeTelemetry, executionId } = (0, telemetry_1.subscribeTelemetry)(events_1.MetadataEvent.APPLE_METADATA_DOWNLOAD, { app, auth });
    log_1.default.addNewLineIfNone();
    log_1.default.log('Downloading App Store config...');
    const errors = [];
    const config = (0, config_1.createAppleWriter)();
    const tasks = (0, tasks_1.createAppleTasks)(metadataCtx);
    const taskCtx = { app };
    for (const task of tasks) {
        try {
            await task.prepareAsync({ context: taskCtx });
        }
        catch (error) {
            errors.push(error);
        }
    }
    for (const task of tasks) {
        try {
            await task.downloadAsync({ config, context: taskCtx });
        }
        catch (error) {
            errors.push(error);
        }
    }
    try {
        await fs_extra_1.default.writeJSON(filePath, config.toSchema(), { spaces: 2 });
    }
    finally {
        unsubscribeTelemetry();
    }
    if (errors.length > 0) {
        throw new errors_1.MetadataDownloadError(errors, executionId);
    }
    return filePath;
}
exports.downloadMetadataAsync = downloadMetadataAsync;
